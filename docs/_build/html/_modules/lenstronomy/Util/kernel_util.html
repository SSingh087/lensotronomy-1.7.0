
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>lenstronomy.Util.kernel_util &#8212; lenstronomy 1.7.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">lenstronomy 1.7.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for lenstronomy.Util.kernel_util</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">routines that manipulate convolution kernels</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage.interpolation</span> <span class="k">as</span> <span class="nn">interp</span>
<span class="kn">import</span> <span class="nn">lenstronomy.Util.util</span> <span class="k">as</span> <span class="nn">util</span>
<span class="kn">import</span> <span class="nn">lenstronomy.Util.image_util</span> <span class="k">as</span> <span class="nn">image_util</span>
<span class="kn">from</span> <span class="nn">lenstronomy.LightModel.Profiles.gaussian</span> <span class="k">import</span> <span class="n">Gaussian</span>
<span class="kn">import</span> <span class="nn">lenstronomy.Util.multi_gauss_expansion</span> <span class="k">as</span> <span class="nn">mge</span>

<span class="kn">from</span> <span class="nn">lenstronomy.Util.package_util</span> <span class="k">import</span> <span class="n">exporter</span>
<span class="n">export</span><span class="p">,</span> <span class="n">__all__</span> <span class="o">=</span> <span class="n">exporter</span><span class="p">()</span>


<div class="viewcode-block" id="de_shift_kernel"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.de_shift_kernel">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">de_shift_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">shift_x</span><span class="p">,</span> <span class="n">shift_y</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">fractional_step_size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    de-shifts a shifted kernel to the center of a pixel. This is performed iteratively.</span>

<span class="sd">    The input kernel is the solution of a linear interpolated shift of a sharper kernel centered in the middle of the</span>
<span class="sd">     pixel. To find the de-shifted kernel, we perform an iterative correction of proposed de-shifted kernels and compare</span>
<span class="sd">     its shifted version with the input kernel.</span>

<span class="sd">    :param kernel: (shifted) kernel, e.g. a star in an image that is not centered in the pixel grid</span>
<span class="sd">    :param shift_x: x-offset relative to the center of the pixel (sub-pixel shift)</span>
<span class="sd">    :param shift_y: y-offset relative to the center of the pixel (sub-pixel shift)</span>
<span class="sd">    :param iterations: number of repeated iterations of shifting a new de-shifted kernel and apply corrections</span>
<span class="sd">    :param fractional_step_size: float (0, 1] correction factor relative to previous proposal (can be used for stability</span>
<span class="sd">    :return: de-shifted kernel such that the interpolated shift boy (shift_x, shift_y) results in the input kernel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">kernel_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nx</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">kernel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">kernel</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mf">4.</span>
    <span class="n">kernel_new</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel</span>
    <span class="n">int_shift_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">shift_x</span><span class="p">))</span>
    <span class="n">frac_x_shift</span> <span class="o">=</span> <span class="n">shift_x</span> <span class="o">-</span> <span class="n">int_shift_x</span>
    <span class="n">int_shift_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">shift_y</span><span class="p">))</span>
    <span class="n">frac_y_shift</span> <span class="o">=</span> <span class="n">shift_y</span> <span class="o">-</span> <span class="n">int_shift_y</span>
    <span class="n">kernel_init</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kernel_new</span><span class="p">)</span>
    <span class="n">kernel_init_shifted</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">interp</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">kernel_init</span><span class="p">,</span> <span class="p">[</span><span class="n">int_shift_y</span><span class="p">,</span> <span class="n">int_shift_x</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">kernel_new</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">kernel_new</span><span class="p">,</span> <span class="p">[</span><span class="n">int_shift_y</span><span class="p">,</span> <span class="n">int_shift_x</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel_init_shifted</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
        <span class="n">kernel_shifted_inv</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">kernel_new</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">frac_y_shift</span><span class="p">,</span> <span class="o">-</span><span class="n">frac_x_shift</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">kernel_init_shifted</span> <span class="o">-</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel_shifted_inv</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span>
        <span class="n">kernel_new</span> <span class="o">+=</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">fractional_step_size</span>
        <span class="n">kernel_new</span> <span class="o">=</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel_new</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span>
    <span class="k">return</span> <span class="n">kernel_new</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="center_kernel"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.center_kernel">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">center_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    given a kernel that might not be perfectly centered, this routine computes its light weighted center and then</span>
<span class="sd">    moves the center in an iterative process such that it is centered</span>

<span class="sd">    :param kernel: 2d array (odd numbers)</span>
<span class="sd">    :param iterations: int, number of iterations</span>
<span class="sd">    :return: centered kernel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nx</span> <span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;kernel needs odd number of pixels&quot;</span><span class="p">)</span>
    <span class="c1"># make coordinate grid of kernel</span>
    <span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">make_grid</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">deltapix</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">left_lower</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># compute 1st moments to get light weighted center</span>
    <span class="n">x_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span> <span class="o">*</span> <span class="n">util</span><span class="o">.</span><span class="n">array2image</span><span class="p">(</span><span class="n">x_grid</span><span class="p">))</span>
    <span class="n">y_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span> <span class="o">*</span> <span class="n">util</span><span class="o">.</span><span class="n">array2image</span><span class="p">(</span><span class="n">y_grid</span><span class="p">))</span>
    <span class="c1"># de-shift kernel</span>
    <span class="n">kernel_centered</span> <span class="o">=</span> <span class="n">de_shift_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">shift_x</span><span class="o">=-</span><span class="n">x_w</span><span class="p">,</span> <span class="n">shift_y</span><span class="o">=-</span><span class="n">y_w</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel_centered</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_norm"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.kernel_norm">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">kernel_norm</span><span class="p">(</span><span class="n">kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param kernel:</span>
<span class="sd">    :return: normalisation of the psf kernel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel</span><span class="p">))</span>
    <span class="n">kernel</span> <span class="o">/=</span> <span class="n">norm</span>
    <span class="k">return</span> <span class="n">kernel</span></div>


<div class="viewcode-block" id="subgrid_kernel"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.subgrid_kernel">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">subgrid_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">subgrid_res</span><span class="p">,</span> <span class="n">odd</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    creates a higher resolution kernel with subgrid resolution as an interpolation of the original kernel in an</span>
<span class="sd">    iterative approach</span>

<span class="sd">    :param kernel: initial kernel</span>
<span class="sd">    :param subgrid_res: subgrid resolution required</span>
<span class="sd">    :return: kernel with higher resolution (larger)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">subgrid_res</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">subgrid_res</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subgrid_res</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kernel</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">d_x</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">nx</span>
    <span class="n">x_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">d_x</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">d_x</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
    <span class="n">d_y</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">nx</span>
    <span class="n">y_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">d_y</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">d_y</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
    <span class="n">nx_new</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">*</span> <span class="n">subgrid_res</span>
    <span class="n">ny_new</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">*</span> <span class="n">subgrid_res</span>
    <span class="k">if</span> <span class="n">odd</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">nx_new</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nx_new</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ny_new</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ny_new</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="n">d_x_new</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">nx_new</span>
    <span class="n">d_y_new</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">ny_new</span>
    <span class="n">x_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">d_x_new</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">d_x_new</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">nx_new</span><span class="p">)</span>
    <span class="n">y_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">d_y_new</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">d_y_new</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">ny_new</span><span class="p">)</span>
    <span class="n">kernel_input</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">kernel_subgrid</span> <span class="o">=</span> <span class="n">image_util</span><span class="o">.</span><span class="n">re_size_array</span><span class="p">(</span><span class="n">x_in</span><span class="p">,</span> <span class="n">y_in</span><span class="p">,</span> <span class="n">kernel_input</span><span class="p">,</span> <span class="n">x_out</span><span class="p">,</span> <span class="n">y_out</span><span class="p">)</span>
    <span class="n">kernel_subgrid</span> <span class="o">=</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel_subgrid</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">num_iter</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="c1"># given a proposition, re-size it to original pixel size</span>
        <span class="k">if</span> <span class="n">subgrid_res</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">kernel_pixel</span> <span class="o">=</span> <span class="n">averaging_even_kernel</span><span class="p">(</span><span class="n">kernel_subgrid</span><span class="p">,</span> <span class="n">subgrid_res</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kernel_pixel</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">averaging</span><span class="p">(</span><span class="n">kernel_subgrid</span><span class="p">,</span> <span class="n">numGrid</span><span class="o">=</span><span class="n">nx_new</span><span class="p">,</span> <span class="n">numPix</span><span class="o">=</span><span class="n">nx</span><span class="p">)</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">-</span> <span class="n">kernel_pixel</span>
        <span class="n">temp_kernel</span> <span class="o">=</span> <span class="n">kernel_input</span> <span class="o">+</span> <span class="n">delta</span>
        <span class="n">kernel_subgrid</span> <span class="o">=</span> <span class="n">image_util</span><span class="o">.</span><span class="n">re_size_array</span><span class="p">(</span><span class="n">x_in</span><span class="p">,</span> <span class="n">y_in</span><span class="p">,</span> <span class="n">temp_kernel</span><span class="p">,</span> <span class="n">x_out</span><span class="p">,</span> <span class="n">y_out</span><span class="p">)</span><span class="c1">#/norm_subgrid</span>
        <span class="n">kernel_subgrid</span> <span class="o">=</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel_subgrid</span><span class="p">)</span>
        <span class="n">kernel_input</span> <span class="o">=</span> <span class="n">temp_kernel</span>

    <span class="c1">#from scipy.ndimage import zoom</span>

    <span class="c1">#ratio = subgrid_res</span>
    <span class="c1">#kernel_subgrid = zoom(kernel, ratio, order=4) / ratio ** 2</span>
    <span class="c1">#print(np.shape(kernel_subgrid))</span>
    <span class="c1"># whatever has not been matched is added to zeroth order (in squares of the undersampled PSF)</span>
    <span class="k">if</span> <span class="n">subgrid_res</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kernel_subgrid</span>
    <span class="n">kernel_pixel</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">averaging</span><span class="p">(</span><span class="n">kernel_subgrid</span><span class="p">,</span> <span class="n">numGrid</span><span class="o">=</span><span class="n">nx_new</span><span class="p">,</span> <span class="n">numPix</span><span class="o">=</span><span class="n">nx</span><span class="p">)</span>
    <span class="n">kernel_pixel</span> <span class="o">=</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel_pixel</span><span class="p">)</span>
    <span class="n">delta_kernel</span> <span class="o">=</span> <span class="n">kernel_pixel</span> <span class="o">-</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="nb">id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">subgrid_res</span><span class="p">,</span> <span class="n">subgrid_res</span><span class="p">))</span>
    <span class="n">delta_kernel_sub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">delta_kernel</span><span class="p">,</span> <span class="nb">id</span><span class="p">)</span><span class="o">/</span><span class="n">subgrid_res</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel_subgrid</span> <span class="o">-</span> <span class="n">delta_kernel_sub</span><span class="p">)</span></div>


<div class="viewcode-block" id="averaging_even_kernel"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.averaging_even_kernel">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">averaging_even_kernel</span><span class="p">(</span><span class="n">kernel_high_res</span><span class="p">,</span> <span class="n">subgrid_res</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    makes a lower resolution kernel based on the kernel_high_res (odd numbers) and the subgrid_res (even number), both</span>
<span class="sd">    meant to be centered.</span>

<span class="sd">    :param kernel_high_res: high resolution kernel with even subsampling resolution, centered</span>
<span class="sd">    :param subgrid_res: subsampling resolution (even number)</span>
<span class="sd">    :return: averaged undersampling kernel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_kernel_high_res</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kernel_high_res</span><span class="p">)</span>
    <span class="n">n_low</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n_kernel_high_res</span> <span class="o">/</span> <span class="n">subgrid_res</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">n_low</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_low</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">n_high</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_low</span> <span class="o">*</span> <span class="n">subgrid_res</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n_high</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n_high</span> <span class="o">==</span> <span class="n">n_kernel_high_res</span><span class="p">:</span>
        <span class="n">kernel_high_res_edges</span> <span class="o">=</span> <span class="n">kernel_high_res</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n_high</span> <span class="o">-</span> <span class="n">n_kernel_high_res</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">kernel_high_res_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_high</span><span class="p">,</span> <span class="n">n_high</span><span class="p">))</span>
        <span class="n">kernel_high_res_edges</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span><span class="o">-</span><span class="n">i_start</span><span class="p">,</span> <span class="n">i_start</span><span class="p">:</span><span class="o">-</span><span class="n">i_start</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel_high_res</span>
    <span class="n">kernel_low_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_low</span><span class="p">,</span> <span class="n">n_low</span><span class="p">))</span>
    <span class="c1"># adding pixels that are fully within a single re-binned pixel</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subgrid_res</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subgrid_res</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">kernel_low_res</span> <span class="o">+=</span> <span class="n">kernel_high_res_edges</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">,</span> <span class="n">j</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">]</span>
    <span class="c1"># adding half of a pixel that has over-lap with two pixels</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">subgrid_res</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subgrid_res</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">kernel_low_res</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">kernel_high_res_edges</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">,</span> <span class="n">j</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">kernel_low_res</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">kernel_high_res_edges</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">,</span> <span class="n">j</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">subgrid_res</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subgrid_res</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">kernel_low_res</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">kernel_high_res_edges</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">,</span> <span class="n">j</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">kernel_low_res</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">kernel_high_res_edges</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">,</span> <span class="n">j</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="c1"># adding a quarter of a pixel value that is at the boarder of four pixels</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">subgrid_res</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">subgrid_res</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">kernel_edge</span> <span class="o">=</span> <span class="n">kernel_high_res_edges</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">,</span> <span class="n">j</span><span class="p">::</span><span class="n">subgrid_res</span><span class="p">]</span>
    <span class="n">kernel_low_res</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">kernel_edge</span> <span class="o">/</span> <span class="mi">4</span>
    <span class="n">kernel_low_res</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">kernel_edge</span> <span class="o">/</span> <span class="mi">4</span>
    <span class="n">kernel_low_res</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">kernel_edge</span> <span class="o">/</span> <span class="mi">4</span>
    <span class="n">kernel_low_res</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">kernel_edge</span> <span class="o">/</span> <span class="mi">4</span>
    <span class="k">return</span> <span class="n">kernel_low_res</span></div>


<div class="viewcode-block" id="kernel_pixelsize_change"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.kernel_pixelsize_change">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">kernel_pixelsize_change</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">deltaPix_in</span><span class="p">,</span> <span class="n">deltaPix_out</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    change the pixel size of a given kernel</span>
<span class="sd">    :param kernel:</span>
<span class="sd">    :param deltaPix_in:</span>
<span class="sd">    :param deltaPix_out:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numPix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">numPix_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">numPix</span> <span class="o">*</span> <span class="n">deltaPix_in</span><span class="o">/</span><span class="n">deltaPix_out</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">numPix_new</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">numPix_new</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">x_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">numPix</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">deltaPix_in</span><span class="p">,</span> <span class="p">(</span><span class="n">numPix</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">deltaPix_in</span><span class="p">,</span> <span class="n">numPix</span><span class="p">)</span>
    <span class="n">x_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">numPix_new</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">deltaPix_out</span><span class="p">,</span> <span class="p">(</span><span class="n">numPix_new</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">deltaPix_out</span><span class="p">,</span> <span class="n">numPix_new</span><span class="p">)</span>
    <span class="n">kernel_out</span> <span class="o">=</span> <span class="n">image_util</span><span class="o">.</span><span class="n">re_size_array</span><span class="p">(</span><span class="n">x_in</span><span class="p">,</span> <span class="n">x_in</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">x_out</span><span class="p">,</span> <span class="n">x_out</span><span class="p">)</span>
    <span class="n">kernel_out</span> <span class="o">=</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel_out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kernel_out</span></div>


<div class="viewcode-block" id="cut_psf"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.cut_psf">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">cut_psf</span><span class="p">(</span><span class="n">psf_data</span><span class="p">,</span> <span class="n">psf_size</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    cut the psf properly</span>
<span class="sd">    :param psf_data: image of PSF</span>
<span class="sd">    :param psf_size: size of psf</span>
<span class="sd">    :return: re-sized and re-normalized PSF</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">image_util</span><span class="o">.</span><span class="n">cut_edges</span><span class="p">(</span><span class="n">psf_data</span><span class="p">,</span> <span class="n">psf_size</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kernel</span></div>


<div class="viewcode-block" id="pixel_kernel"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.pixel_kernel">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">pixel_kernel</span><span class="p">(</span><span class="n">point_source_kernel</span><span class="p">,</span> <span class="n">subgrid_res</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    converts a pixelised kernel of a point source to a kernel representing a uniform extended pixel</span>

<span class="sd">    :param point_source_kernel:</span>
<span class="sd">    :param subgrid_res:</span>
<span class="sd">    :return: convolution kernel for an extended pixel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kernel_subgrid</span> <span class="o">=</span> <span class="n">subgrid_kernel</span><span class="p">(</span><span class="n">point_source_kernel</span><span class="p">,</span> <span class="n">subgrid_res</span><span class="p">,</span> <span class="n">num_iter</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">kernel_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">point_source_kernel</span><span class="p">)</span>
    <span class="n">kernel_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">kernel_size</span><span class="o">*</span><span class="n">subgrid_res</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">*</span><span class="n">subgrid_res</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subgrid_res</span><span class="p">):</span>
        <span class="n">k_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">kernel_size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">subgrid_res</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subgrid_res</span><span class="p">):</span>
            <span class="n">k_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">kernel_size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">subgrid_res</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">kernel_pixel</span> <span class="o">=</span> <span class="n">image_util</span><span class="o">.</span><span class="n">add_layer2image</span><span class="p">(</span><span class="n">kernel_pixel</span><span class="p">,</span> <span class="n">k_x</span><span class="p">,</span> <span class="n">k_y</span><span class="p">,</span> <span class="n">kernel_subgrid</span><span class="p">)</span>
    <span class="n">kernel_pixel</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">averaging</span><span class="p">(</span><span class="n">kernel_pixel</span><span class="p">,</span> <span class="n">numGrid</span><span class="o">=</span><span class="n">kernel_size</span><span class="o">*</span><span class="n">subgrid_res</span><span class="p">,</span> <span class="n">numPix</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kernel_norm</span><span class="p">(</span><span class="n">kernel_pixel</span><span class="p">)</span></div>


<div class="viewcode-block" id="kernel_average_pixel"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.kernel_average_pixel">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">kernel_average_pixel</span><span class="p">(</span><span class="n">kernel_super</span><span class="p">,</span> <span class="n">supersampling_factor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    computes the effective convolution kernel assuming a uniform surface brightness on the scale of a pixel</span>

<span class="sd">    :param kernel_super: supersampled PSF of a point source (odd number per axis</span>
<span class="sd">    :param supersampling_factor: supersampling factor (int)</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kernel_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel_super</span><span class="p">)</span>
    <span class="n">kernel_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kernel_super</span><span class="p">)</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">supersampling_factor</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">kernel_size</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">kernel_size</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">n_high</span> <span class="o">=</span> <span class="n">kernel_size</span><span class="o">*</span><span class="n">supersampling_factor</span>
    <span class="k">if</span> <span class="n">n_high</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_high</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">kernel_pixel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_high</span><span class="p">,</span> <span class="n">n_high</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">supersampling_factor</span><span class="p">):</span>
        <span class="n">k_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">kernel_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">supersampling_factor</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">supersampling_factor</span><span class="p">):</span>
            <span class="n">k_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">kernel_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">supersampling_factor</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">kernel_pixel</span> <span class="o">=</span> <span class="n">image_util</span><span class="o">.</span><span class="n">add_layer2image</span><span class="p">(</span><span class="n">kernel_pixel</span><span class="p">,</span> <span class="n">k_x</span><span class="p">,</span> <span class="n">k_y</span><span class="p">,</span> <span class="n">kernel_super</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">supersampling_factor</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">kernel_pixel</span> <span class="o">=</span> <span class="n">averaging_even_kernel</span><span class="p">(</span><span class="n">kernel_pixel</span><span class="p">,</span> <span class="n">supersampling_factor</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kernel_pixel</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">averaging</span><span class="p">(</span><span class="n">kernel_pixel</span><span class="p">,</span> <span class="n">numGrid</span><span class="o">=</span><span class="n">n_high</span><span class="p">,</span>
                                                   <span class="n">numPix</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">)</span>
    <span class="n">kernel_pixel</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel_pixel</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kernel_pixel</span> <span class="o">*</span> <span class="n">kernel_sum</span></div>


<div class="viewcode-block" id="kernel_gaussian"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.kernel_gaussian">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">kernel_gaussian</span><span class="p">(</span><span class="n">kernel_numPix</span><span class="p">,</span> <span class="n">deltaPix</span><span class="p">,</span> <span class="n">fwhm</span><span class="p">):</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">fwhm2sigma</span><span class="p">(</span><span class="n">fwhm</span><span class="p">)</span>
    <span class="c1">#if kernel_numPix % 2 == 0:</span>
    <span class="c1">#    kernel_numPix += 1</span>
    <span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">make_grid</span><span class="p">(</span><span class="n">kernel_numPix</span><span class="p">,</span> <span class="n">deltaPix</span><span class="p">)</span>
    <span class="n">gaussian</span> <span class="o">=</span> <span class="n">Gaussian</span><span class="p">()</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">gaussian</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="n">x_grid</span><span class="p">,</span> <span class="n">y_grid</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">center_x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">center_y</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">array2image</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kernel</span></div>


<div class="viewcode-block" id="split_kernel"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.split_kernel">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">split_kernel</span><span class="p">(</span><span class="n">kernel_super</span><span class="p">,</span> <span class="n">supersampling_kernel_size</span><span class="p">,</span> <span class="n">supersampling_factor</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pixel kernel and subsampling kernel such that the convolution of both applied on an image can be</span>
<span class="sd">    performed, i.e. smaller subsampling PSF and hole in larger PSF</span>

<span class="sd">    :param kernel: PSF kernel of the size of the pixel</span>
<span class="sd">    :param kernel_super: super-sampled kernel</span>
<span class="sd">    :param supersampling_kernel_size: size of super-sampled PSF in units of degraded pixels</span>
<span class="sd">    :param normalized: boolean, if True returns a split kernel that is area normalized=1 representing a convolution kernel</span>
<span class="sd">    :return: degraded kernel with hole and super-sampled kernel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">supersampling_factor</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;To split a kernel, the supersampling_factor needs to be &gt; 1, givn </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">supersampling_factor</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">supersampling_kernel_size</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;supersampling_kernel_size needs to be an odd number!&#39;</span><span class="p">)</span>
    <span class="n">n_super</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kernel_super</span><span class="p">)</span>
    <span class="n">n_sub</span> <span class="o">=</span> <span class="n">supersampling_kernel_size</span> <span class="o">*</span> <span class="n">supersampling_factor</span>
    <span class="k">if</span> <span class="n">n_sub</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_sub</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">n_sub</span> <span class="o">&gt;</span> <span class="n">n_super</span><span class="p">:</span>
        <span class="n">n_sub</span> <span class="o">=</span> <span class="n">n_super</span>

    <span class="n">kernel_hole</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">kernel_super</span><span class="p">)</span>
    <span class="n">n_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n_super</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_sub</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">n_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n_super</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_sub</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">kernel_hole</span><span class="p">[</span><span class="n">n_min</span><span class="p">:</span><span class="n">n_max</span><span class="p">,</span> <span class="n">n_min</span><span class="p">:</span><span class="n">n_max</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">kernel_hole_resized</span> <span class="o">=</span> <span class="n">degrade_kernel</span><span class="p">(</span><span class="n">kernel_hole</span><span class="p">,</span> <span class="n">degrading_factor</span><span class="o">=</span><span class="n">supersampling_factor</span><span class="p">)</span>
    <span class="n">kernel_subgrid_cut</span> <span class="o">=</span> <span class="n">kernel_super</span><span class="p">[</span><span class="n">n_min</span><span class="p">:</span><span class="n">n_max</span><span class="p">,</span> <span class="n">n_min</span><span class="p">:</span><span class="n">n_max</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">normalized</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">flux_subsampled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel_subgrid_cut</span><span class="p">)</span>
        <span class="n">flux_hole</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel_hole_resized</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">flux_hole</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">kernel_hole_resized</span> <span class="o">*=</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">flux_subsampled</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel_hole_resized</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kernel_subgrid_cut</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kernel_subgrid_cut</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kernel_hole_resized</span> <span class="o">/=</span> <span class="n">supersampling_factor</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">kernel_hole_resized</span><span class="p">,</span> <span class="n">kernel_subgrid_cut</span></div>


<div class="viewcode-block" id="degrade_kernel"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.degrade_kernel">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">degrade_kernel</span><span class="p">(</span><span class="n">kernel_super</span><span class="p">,</span> <span class="n">degrading_factor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param kernel_super: higher resolution kernel (odd number per axis)</span>
<span class="sd">    :param degrading_factor: degrading factor (effectively the super-sampling resolution of the kernel given</span>
<span class="sd">    :return: degraded kernel with odd axis number with the sum of the flux/values in the kernel being preserved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">degrading_factor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kernel_super</span>
    <span class="k">if</span> <span class="n">degrading_factor</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">kernel_low_res</span> <span class="o">=</span> <span class="n">averaging_even_kernel</span><span class="p">(</span><span class="n">kernel_super</span><span class="p">,</span> <span class="n">degrading_factor</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_kernel</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kernel_super</span><span class="p">)</span>
        <span class="n">numPix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">n_kernel</span> <span class="o">/</span> <span class="n">degrading_factor</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">numPix</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">numPix</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">n_high</span> <span class="o">=</span> <span class="n">numPix</span> <span class="o">*</span> <span class="n">degrading_factor</span>

        <span class="n">kernel_super_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_high</span><span class="p">,</span> <span class="n">n_high</span><span class="p">))</span>
        <span class="n">i_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n_high</span><span class="o">-</span><span class="n">n_kernel</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">kernel_super_</span><span class="p">[</span><span class="n">i_start</span><span class="p">:</span><span class="n">i_start</span><span class="o">+</span><span class="n">n_kernel</span><span class="p">,</span> <span class="n">i_start</span><span class="p">:</span><span class="n">i_start</span><span class="o">+</span><span class="n">n_kernel</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel_super</span>
        <span class="n">kernel_low_res</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">averaging</span><span class="p">(</span><span class="n">kernel_super_</span><span class="p">,</span> <span class="n">numGrid</span><span class="o">=</span><span class="n">n_high</span><span class="p">,</span> <span class="n">numPix</span><span class="o">=</span><span class="n">numPix</span><span class="p">)</span> <span class="o">*</span> <span class="n">degrading_factor</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># multiplicative factor added when providing flux conservation</span>
    <span class="k">return</span> <span class="n">kernel_low_res</span></div>


<div class="viewcode-block" id="cutout_source"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.cutout_source">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">cutout_source</span><span class="p">(</span><span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">kernelsize</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    cuts out point source (e.g. PSF estimate) out of image and shift it to the center of a pixel</span>
<span class="sd">    :param x_pos:</span>
<span class="sd">    :param y_pos:</span>
<span class="sd">    :param image:</span>
<span class="sd">    :param kernelsize:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kernelsize</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;even pixel number kernel size not supported!&quot;</span><span class="p">)</span>
    <span class="n">x_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">x_pos</span><span class="p">))</span>
    <span class="n">y_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">y_pos</span><span class="p">))</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">kernelsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x_int</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x_int</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y_int</span> <span class="o">+</span> <span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y_int</span> <span class="o">-</span> <span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">image_cut</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">])</span>
    <span class="n">shift_x</span> <span class="o">=</span> <span class="n">x_int</span> <span class="o">-</span> <span class="n">x_pos</span>
    <span class="n">shift_y</span> <span class="o">=</span> <span class="n">y_int</span> <span class="o">-</span> <span class="n">y_pos</span>
    <span class="k">if</span> <span class="n">shift</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">kernel_shift</span> <span class="o">=</span> <span class="n">de_shift_kernel</span><span class="p">(</span><span class="n">image_cut</span><span class="p">,</span> <span class="n">shift_x</span><span class="p">,</span> <span class="n">shift_y</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kernel_shift</span> <span class="o">=</span> <span class="n">image_cut</span>
    <span class="n">kernel_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">kernelsize</span><span class="p">,</span> <span class="n">kernelsize</span><span class="p">))</span>

    <span class="n">k_l2_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">kernelsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">k_l2_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">kernelsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">xk_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">x_int</span> <span class="o">+</span> <span class="n">k_l2_x</span><span class="p">)</span>
    <span class="n">yk_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">y_int</span> <span class="o">+</span> <span class="n">k_l2_y</span><span class="p">)</span>
    <span class="n">xk_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">kernelsize</span><span class="p">,</span> <span class="o">-</span><span class="n">x_int</span> <span class="o">+</span> <span class="n">k_l2_x</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">yk_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">kernelsize</span><span class="p">,</span> <span class="o">-</span><span class="n">y_int</span> <span class="o">+</span> <span class="n">k_l2_y</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span>

    <span class="n">kernel_final</span><span class="p">[</span><span class="n">yk_min</span><span class="p">:</span><span class="n">yk_max</span><span class="p">,</span> <span class="n">xk_min</span><span class="p">:</span><span class="n">xk_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel_shift</span>
    <span class="k">return</span> <span class="n">kernel_final</span></div>


<div class="viewcode-block" id="fwhm_kernel"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.fwhm_kernel">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">fwhm_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    :param kernel:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">I_r</span> <span class="o">=</span> <span class="n">image_util</span><span class="o">.</span><span class="n">radial_profile</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="n">center</span><span class="p">,</span> <span class="n">center</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only works with odd number of pixels in kernel!&#39;</span><span class="p">)</span>
    <span class="n">max_flux</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">[</span><span class="nb">int</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
    <span class="n">I_2</span> <span class="o">=</span> <span class="n">max_flux</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.33</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">I_r</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">I_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">I_2</span><span class="p">:</span>
            <span class="n">fwhm_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">I_2</span> <span class="o">-</span> <span class="n">I_r</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">I_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">I_r</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">fwhm_2</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The kernel did not drop to half the max value - fwhm not determined!&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="estimate_amp"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.estimate_amp">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">estimate_amp</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x_pos</span><span class="p">,</span> <span class="n">y_pos</span><span class="p">,</span> <span class="n">psf_kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    estimates the amplitude of a point source located at x_pos, y_pos</span>
<span class="sd">    :param data:</span>
<span class="sd">    :param x_pos:</span>
<span class="sd">    :param y_pos:</span>
<span class="sd">    :param deltaPix:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numPix_x</span><span class="p">,</span> <span class="n">numPix_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="c1">#data_center = int((numPix-1.)/2)</span>
    <span class="n">x_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">x_pos</span><span class="o">-</span><span class="mf">0.49999</span><span class="p">))</span><span class="c1">#+data_center</span>
    <span class="n">y_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">y_pos</span><span class="o">-</span><span class="mf">0.49999</span><span class="p">))</span><span class="c1">#+data_center</span>
    <span class="c1"># TODO: make amplitude estimate not sucecible to rounding effects on which pixels to chose to estimate the amplitude</span>
    <span class="k">if</span> <span class="n">x_int</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">x_int</span> <span class="o">&lt;</span> <span class="n">numPix_x</span><span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">y_int</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y_int</span> <span class="o">&lt;</span> <span class="n">numPix_y</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">mean_image</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y_int</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span><span class="n">y_int</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">x_int</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="n">x_int</span><span class="o">+</span><span class="mi">3</span><span class="p">]),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psf_kernel</span><span class="p">)</span>
        <span class="n">center</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">num</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">mean_kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">psf_kernel</span><span class="p">[</span><span class="n">center</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="n">center</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">center</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="n">center</span><span class="o">+</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">amp_estimated</span> <span class="o">=</span> <span class="n">mean_image</span><span class="o">/</span><span class="n">mean_kernel</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">amp_estimated</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">amp_estimated</span></div>


<div class="viewcode-block" id="mge_kernel"><a class="viewcode-back" href="../../../lenstronomy.Util.html#lenstronomy.Util.kernel_util.mge_kernel">[docs]</a><span class="nd">@export</span>
<span class="k">def</span> <span class="nf">mge_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    azimutal Multi-Gaussian expansion of a pixelized kernel</span>

<span class="sd">    :param kernel: 2d numpy array</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># radial average</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">center</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
    <span class="n">psf_r</span> <span class="o">=</span> <span class="n">image_util</span><span class="o">.</span><span class="n">radial_profile</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">[</span><span class="n">center</span><span class="p">,</span> <span class="n">center</span><span class="p">])</span>
    <span class="c1"># MGE of radial average</span>
    <span class="n">n_r</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">psf_r</span><span class="p">)</span>
    <span class="n">r_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n_r</span><span class="p">)</span>
    <span class="n">amps</span><span class="p">,</span> <span class="n">sigmas</span><span class="p">,</span> <span class="n">norm</span> <span class="o">=</span> <span class="n">mge</span><span class="o">.</span><span class="n">mge_1d</span><span class="p">(</span><span class="n">r_array</span><span class="p">,</span> <span class="n">psf_r</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">linspace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">amps</span><span class="p">,</span> <span class="n">sigmas</span><span class="p">,</span> <span class="n">norm</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">lenstronomy 1.7.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Simon Birrer and contributors.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.0.
    </div>
  </body>
</html>